		ConfigStruct struct = new ConfigStruct(key, config.isSorted(), 32);

		parseConfiguration(reader, struct);


		StringBuilder key = new StringBuilder(40);

		while (true) {
			int c = reader.nextChar();
			if (c < 0)
				return;

			// Check what character this is
			switch (c) {
				case '\n': // New line
					// Add this to the key as a space.
					// Spaces are not allowed, but it will be trimmed
					// when its the first or last character.
					key += " ";
					break;
				case '=': // Assignment

					// Validate key
					if (validateKey(key.trim(), file, lineNumber)) {
						// Now parsing assignment
						Object val = ParseAssignment(ref file, data, pos, lineNumber);
						if (!cpErrorResult) {
							configStruct[key.trim()] = val;
							key = "";
						}
					}
					break;
				case '{': // Begin of new struct
					parseStruct(key.toString(), reader, config);
					key.setLength(0);
					break;
				case '}': // Done with this struct
					return;
				case '(': // Function
					ParseFunction(configStruct, file, data, pos, lineNumber, key);
					key = "";
					break;

				case ';': // Terminator

					// Validate key
					if (!String.IsNullOrEmpty(key)) {
						if (validateKey(key.trim(), file, lineNumber)) {
							// Add the key with null as value
							configStruct[key.trim()] = null;
							key = "";
						}
					}
					break;


				case '\\': // Possible comment
				case '/':

					// Backtrack to use previous character also
					pos--;

					// Check for the line comment //
					if (data.Substring(pos, 2) == "//") {
						// Find the next line
						int np = data.IndexOf("\n", pos, StringComparison.Ordinal);

						// Next line found?
						if (np > -1) {
							// Count the line
							lineNumber++;

							// Skip everything on this line
							pos = np + 1;
						} else {
							// No end of line
							// Skip everything else
							pos = data.Length + 1;
						}
					}
					// Check for the block comment /* */
					else if (data.Substring(pos, 2) == "/*") {
						// Find the next closing block comment
						int np = data.IndexOf("*/", pos, StringComparison.Ordinal);

						// Closing block comment found?
						if (np > -1) {
							// Count the lines in the block comment
							String blockdata = data.Substring(pos, np - pos + 2);
							lineNumber += (blockdata.Split(newline).Length - 1);

							// Skip everything in this block
							pos = np + 2;
						} else {
							// No end of line
							// Skip everything else
							pos = data.Length + 1;
						}
					} else {
						// No whitespace
						pos++;
					}
					break;

				default: // Everything else

					// Add character to key
					key += c.ToString(CultureInfo.InvariantCulture);
					break;
			}
		}
